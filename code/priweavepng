#!/usr/bin/env python

# priweavepng
# Weave selected channels from input PNG files into
# a multi-channel output PNG.

import argparse
import collections
import sys

from array import array

import png

"""
priweavepng file1.png [file2.png ...]

priweavepng can be used to combine 3 greyscale PNG files into a colour, RGB,
PNG file.  In fact it is slightly more general than that.  The number of
channels in the output PNG is equal to the number of selected
input channels.
It is an error if this sum exceeds 4
(the maximum number of channels in a PNG image is 4, for an RGBA image).
The output colour mode corresponds to the number of channels:o
1 - greyscale; 2 - greyscale+alpha; 3 - RGB; 4 - RGB+alpha.

In this way it is possible to combine 3 greyscale PNG files into an RGB
PNG (a common expected use) as well as more esoteric options: rgb.png +
grey.png = rgba.png; grey.png + grey.png = greyalpha.png.
"""

Image = collections.namedtuple("Image", "rows info")


class Error(Exception):
    pass


def stack(out, args):
    """Stack the input PNG files into a single output PNG."""

    paths = args.input

    if len(paths) < 1:
        raise Error("Required input is missing.")

    images = []

    for path in paths:
        inp = cli_open(path)
        rows, info = png.Reader(file=inp).asDirect()[2:]
        rows = list(rows)
        image = Image(rows, info)
        images.append(image)

    totalchannels = sum(image.info['planes'] for image in images)

    if not (0 < totalchannels <= 4):
        raise Error("Too many channels in inputs")
    alpha = totalchannels in (2, 4)
    greyscale = totalchannels in (1, 2)

    bitdepth = [image.info['bitdepth'] for image in images]
    # Currently, fail unless all bitdepths equal.
    if len(set(bitdepth)) > 1:
        raise NotImplementedError("Cannot cope when bitdepths differ - sorry!")
    bitdepth = bitdepth[0]
    arraytype = 'BH'[bitdepth > 8]

    size = [image.info['size'] for image in images]
    # Currently, fail unless all images same size.
    if len(set(size)) > 1:
        raise NotImplementedError("Cannot cope when sizes differ - sorry!")
    size = size[0]

    # Values per row
    vpr = totalchannels * size[0]

    def iterstack():
        # the zip call creates an iterator that yields the next row
        # from all the input images combined into a tuple.
        for irow in zip(*(image.rows for image in images)):
            row = array(arraytype, [0]*vpr)
            # output channel index
            out_channel_i = 0
            for i, arow in enumerate(irow):
                # ensure incoming row is an array
                arow = array(arraytype, arow)
                n = images[i].info['planes']
                for j in range(n):
                    row[out_channel_i::totalchannels] = arow[j::n]
                    out_channel_i += 1
            yield row
    w = png.Writer(
        size[0], size[1],
        greyscale=greyscale, alpha=alpha, bitdepth=bitdepth,
        interlace=args.interlace)
    w.write(out, iterstack())


def cli_open(path):
    if path == "-":
        return binary_stdin()
    return open(path, 'rb')


def binary_stdin():
    """
    A sys.stdin that returns bytes.
    """

    try:
        return sys.stdin.buffer
    except AttributeError:
        # Probably Python 2, where bytes are strings.
        pass
    return sys.stdin


def ensure_binary_stdout():
    """
    Ensure sys.stdout accepts bytes.
    """

    # First there is a Python3 issue.
    try:
        sys.stdout = sys.stdout.buffer
    except AttributeError:
        # Probably Python 2, where bytes are strings.
        pass

    # On Windows the C runtime file orientation needs changing.
    if sys.platform == "win32":
        import msvcrt
        import os
        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)


def main(argv=None):
    if argv is None:
        argv = sys.argv
    argv = argv[1:]

    parser = argparse.ArgumentParser()
    parser.add_argument("--interlace", action="store_true",
                        help="write interlaced PNG")
    parser.add_argument("input", nargs="+")
    args = parser.parse_args(argv)

    ensure_binary_stdout()
    return stack(sys.stdout, args)


if __name__ == '__main__':
    main()
