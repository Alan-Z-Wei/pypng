#!/usr/bin/env python

# priweavepng
# Weave selected channels from input PNG files into
# a multi-channel output PNG.

from __future__ import print_function

import argparse
import collections
import itertools
import re
import sys

from array import array

import png

"""
priweavepng file1.png [file2.png ...]

priweavepng can be used to combine 3 greyscale PNG files into a colour, RGB,
PNG file.  In fact it is slightly more general than that.  The number of
channels in the output PNG is equal to the number of selected
input channels.
It is an error if this sum exceeds 4
(the maximum number of channels in a PNG image is 4, for an RGBA image).
The output colour mode corresponds to the number of channels:o
1 - greyscale; 2 - greyscale+alpha; 3 - RGB; 4 - RGB+alpha.

In this way it is possible to combine 3 greyscale PNG files into an RGB
PNG (a common expected use) as well as more esoteric options: rgb.png +
grey.png = rgba.png; grey.png + grey.png = greyalpha.png.
"""

Image = collections.namedtuple("Image", "rows info")


class Error(Exception):
    pass


def stack(out, args):
    """Stack the input PNG files and extract channels
    into a single output PNG.
    """

    paths = args.input

    if len(paths) < 1:
        raise Error("Required input is missing.")

    # List of Image instances
    images = []
    # Channel map. Maps from channel number (starting from 1)
    # to an (image_index, channel_index) pair.
    channel_map = dict()
    channel = 1

    for image_index,path in enumerate(paths):
        inp = cli_open(path)
        rows, info = png.Reader(file=inp).asDirect()[2:]
        rows = list(rows)
        image = Image(rows, info)
        images.append(image)
        for i in range(image.info['planes']):
            channel_map[channel+i] = (image_index, i)
        channel += image.info['planes']

    assert channel - 1 == sum(image.info['planes'] for image in images)

    # If no channels, select up to first 4 as default.
    if not args.channel:
        args.channel = range(1, channel)[:4]

    out_channels = len(args.channel)
    if not (0 < out_channels <= 4):
        raise Error("Too many channels selected (must be 1 to 4)")
    alpha = out_channels in (2, 4)
    greyscale = out_channels in (1, 2)

    bitdepth = [image.info['bitdepth'] for image in images]
    # Currently, fail unless all bitdepths equal.
    # :todo: create sBIT chunk instead of failing.
    if len(set(bitdepth)) > 1:
        raise NotImplementedError("Cannot cope when bitdepths differ - sorry!")
    bitdepth = bitdepth[0]
    arraytype = 'BH'[bitdepth > 8]

    size = [image.info['size'] for image in images]
    # Currently, fail unless all images same size.
    if len(set(size)) > 1:
        raise NotImplementedError("Cannot cope when sizes differ - sorry!")
    size = size[0]

    # Values per row, of output image
    vpr = out_channels * size[0]

    def weave_row_iter():
        """
        Yield each woven row in turn.
        """
        # The zip call creates an iterator that yields
        # a tuple with each element containing the next row
        # for each of the input images.
        for row_tuple in zip(*(image.rows for image in images)):
            # output row
            row = array(arraytype, [0]*vpr)
            # for each output channel select correct input channel
            for out_channel_i, channel in enumerate(args.channel):
                image_i, channel_i = channel_map[channel]
                # incoming row (make it an array)
                irow = array(arraytype, row_tuple[image_i])
                n = images[image_i].info['planes']
                row[out_channel_i::out_channels] = irow[channel_i::n]
            yield row
    w = png.Writer(
        size[0], size[1],
        greyscale=greyscale, alpha=alpha, bitdepth=bitdepth,
        interlace=args.interlace)
    w.write(out, weave_row_iter())


def cli_open(path):
    if path == "-":
        return binary_stdin()
    return open(path, 'rb')


def binary_stdin():
    """
    A sys.stdin that returns bytes.
    """

    try:
        return sys.stdin.buffer
    except AttributeError:
        # Probably Python 2, where bytes are strings.
        pass
    return sys.stdin


def ensure_binary_stdout():
    """
    Ensure sys.stdout accepts bytes.
    """

    # First there is a Python3 issue.
    try:
        sys.stdout = sys.stdout.buffer
    except AttributeError:
        # Probably Python 2, where bytes are strings.
        pass

    # On Windows the C runtime file orientation needs changing.
    if sys.platform == "win32":
        import msvcrt
        import os
        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)


def comma_list(s):
    """
    Type and return a list of integers.
    """

    return [int(c) for c in re.findall(r'\d+', s)]


def main(argv=None):
    if argv is None:
        argv = sys.argv
    argv = argv[1:]

    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--channel", action="append",
            type=comma_list,
            help="list of channels to extract")
    parser.add_argument("--interlace", action="store_true",
                        help="write interlaced PNG")
    parser.add_argument("input", nargs="+")
    args = parser.parse_args(argv)

    if args.channel:
        args.channel = list(itertools.chain(*args.channel))

    ensure_binary_stdout()
    return stack(sys.stdout, args)


if __name__ == '__main__':
    main()
